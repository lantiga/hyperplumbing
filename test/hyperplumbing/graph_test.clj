(ns hyperplumbing.graph-test
  (:use clojure.test
        exoref.connection
        plumbing.core)
  (:require [plumbing.graph :as graph]
            [plumbing.fnk.pfnk :as pfnk]
            [hyperplumbing.graph :as hgraph]))

(def stats-graph
  "A graph specifying the same computation as 'stats' in the Graph sample"
  {:n  (fnk [xs]   (count xs))
   :m  (fnk [xs n] (/ (sum identity xs) n))
   :m2 (fnk [xs n] (/ (sum #(* % %) xs) n))
   :v  (fnk [m m2] (- m2 (* m m)))})

(deftest test-distributed-single-group
  (testing "Test distributed compile, single group."
    (let [stats-eager (graph/eager-compile stats-graph)
          stats-distributed (with-conn (make-conn-pool) (make-conn-spec) (hgraph/distributed-compile stats-graph))
          arg {:xs [1 2 3]}
          stats-eager-val (stats-eager arg)
          stats-distributed-val (stats-distributed arg)]
      (is (= (:v stats-eager-val) (:v stats-distributed-val))))))

(defn assoc-in-meta
  [m ks & meta-kvs]
  (update-in m ks #(apply vary-meta % assoc meta-kvs)))

(deftest test-distributed-two-groups
  (testing "Test distributed compile, two groups. One is a future, it could live on a different machine.
            Redis keys in this test are set explicitly, which is not mandatory."
    (let [stats-graph
          (->
           stats-graph
           (assoc-in-meta [:n]  :group :group-a :redis-key "kn")
           (assoc-in-meta [:m]  :group :group-a :redis-key "km")
           (assoc-in-meta [:m2] :group :group-b :redis-key "km2")
           (assoc-in-meta [:v]  :group :group-b :redis-key "kv"))
          stats-eager (graph/eager-compile stats-graph)
          ;; Here we are passing the current group to distributed compile.
          ;; This could be deferred to when we call the graph function.
          stats-distributed-a (with-conn (make-conn-pool) (make-conn-spec) (hgraph/distributed-compile stats-graph :group-a))
          stats-distributed-b (with-conn (make-conn-pool) (make-conn-spec) (hgraph/distributed-compile stats-graph :group-b))
          arg {:xs [1 2 3]}
          stats-eager-res (stats-eager arg)
          ;; Since the exodelays are generated when the functions are called, we have a chance to specify a redis-key-prefix
          ;; for every call, so to make sure that keys won't clash. Instead of meta, this could probably better be an extra
          ;; argument to the graph function generated by distributed compile.
          arg (with-meta arg {:redis-key-prefix "foo"})
          ;; TODO: with the current compilation function, exodelays are created when stats-distributed-a and -b are called,
          ;; so they will hang unless they are called with the same arguments on all machines. We'll need a way to distribute
          ;; the value (we could use an exopromise) and to elicit the call.
          stats-distributed-a-res (future (stats-distributed-a arg))
          stats-distributed-b-res (stats-distributed-b arg)]
      ;; At this point, stats-distributed-b will run :v and :m2, while :m and :n will be computed by stats-distributed-a.
      (is (= (:v stats-eager-res) (:v stats-distributed-b-res))))))
